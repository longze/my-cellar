# Js 中的16种设计模式

> GoF 四人组总结出23种设计模式,后人对设计模式的评价总体来说赞誉多一点,也有负面意见,认为设计模式就是语言这件衣服的补丁。JavaScript 这件衣服不算太破,前辈们总结出了16种模式来弥补语言设计的"缺陷",在很多事情上选择是对立的,所以这里的缺陷只是一种选择。其实设计模式另一个来源就是实践中总结出来的套路,比如适配器模式在平滑迁移老代码这种场景下特别好用。这篇文章会梳理常用的14种设计模式,力求每个模式给一个项目中的场景(而不是举那些不接地气的例子),从知名框架和库中剥离出其设计模式(这也是一个深入了解知名框架和库的角度)。

## 单例模式

定义: 保证一个类只有一个实例,并提供一个访问它的全局访问点。

对于静态语言(JAVA,C++等)需要对象需要先创建类，而 JS 可以直接定义一个对象。

单例模式主要是两个应用场景：
- 提供全局的工具方法(自执行函数和命名空间对外暴露函数列表)
- 页面中零到多次的功能模块(登录系统错误警告)

## 策略模式

定义：定义一系列方法，使它们之间可以相互替换。

将变化的部分和不变的部分隔离开是包括策略模式在内的多个设计模式的目的。策略模式面向使用者的优点在于封装了不同输入条件调用不同的策略，对策略本身的开发优势在于策略之间的相互隔离；策略模式的局限性在于各个策略之间的排他性设计，如果要添加或修改某个策略需要了解整个计算规则以免在逻辑上有叠加或断层，这时对策略的注释就尤为重要。

策略的适用场景不多，要求根据参数可以抽象出一个模式来，但如果模式逻辑很简单似乎将策略抽象为一个配置文件，比如算工资的那个示例可以做下面改写：

    function calculateBonus(performanceLevel, salary) {
        var config = {
            A: 3,
            B: 2,
            S: 4
        };
        // 这里省去了对参数的校验...
        
        return config[performanceLevel] * salary;
    }    

代码的简洁性一目了然，如果在这样的计算逻辑下添加或修改一个策略成本比示例的方式要低得多。但是如果新策略不是 `performanceLevel*salary` 这样的计算逻辑那这个代码是不是就尴尬了？

我们说两条：
- 程序的扩展性和过度设计之间的界限要把握好；
- 策略逻辑要尽量简化。

我们不知道级别 C 和新的计算逻辑谁先出现，或许他们都不会出现，所以在不知道新需求的方式时当前够用的就是最好的，如果有新的计算逻辑可以这样改造上面函数：
 
    function calculateBonus(performanceLevel, salary) {
        var config = {
            A: handler: function () {
                return 3 * salary;
            }
        };

        var item = config[performanceLevel];
        // 这里省去了对参数的校验...
        
        return item.handler();
    }

没有最好的代码，只有最适合的代码。用配置的方式组织策略，简单到可能认不出这是策略模式。在策略模式中根据策略的异同点来抽象策略的组织是此模式的关键。


