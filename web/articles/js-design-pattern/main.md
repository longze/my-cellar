# Js 中的14种设计模式

> GoF 四人组总结出23种设计模式,后人对设计模式的评价总体来说赞誉多一点,也有负面意见,认为设计模式就是语言这件衣服的补丁。JavaScript 这件衣服不算太破,前辈们总结出了14种模式来弥补语言设计的"缺陷",在很多事情上选择是对立的,所以这里的缺陷只是一种选择。其实设计模式另一个来源就是实践中总结出来的套路,比如适配器模式在平滑迁移老代码这种场景下特别好用。这篇文章会梳理常用的14种设计模式,力求每个模式给一个项目中的场景(而不是举那些不接地气的例子),从知名框架和库中剥离出其设计模式(这也是一个深入了解知名框架和库的角度)。

## 单例模式

定义: 保证一个类只有一个实例,并提供一个访问它的全局访问点。

对于静态语言(JAVA,C++等)需要对象需要先创建类，而 JS 可以直接定义一个对象。

单例模式主要是两个应用场景：
- 提供全局的工具方法(自执行函数和命名空间对外暴露函数列表)
- 页面中零到多次的功能模块(登录系统错误警告)

## 策略模式

定义：定义一系列方法，使它们之间可以相互替换。

将变化的部分和不变的部分隔离开是包括策略模式在内的多个设计模式的目的。策略模式面向使用者的优点在于封装了不同输入条件调用不同的策略，对策略本身的开发优势在于策略之间的相互隔离；策略模式的局限性在于各个策略之间的排他性设计，如果要添加或修改某个策略需要了解整个计算规则以免在逻辑上有叠加或断层，这时对策略的注释就尤为重要。

策略的适用场景不多，要求根据参数可以抽象出一个模式来，但如果模式逻辑很简单似乎将策略抽象为一个配置文件，比如算工资的那个示例可以做下面改写：

    function calculateBonus(performanceLevel, salary) {
        var config = {
            A: 3,
            B: 2,
            S: 4
        };
        // 这里省去了对参数的校验...
        
        return config[performanceLevel] * salary;
    }    

代码的简洁性一目了然，如果在这样的计算逻辑下添加或修改一个策略成本比示例的方式要低得多。但是如果新策略不是 `performanceLevel*salary` 这样的计算逻辑那这个代码是不是就尴尬了？

我们说两条：
- 程序的扩展性和过度设计之间的界限要把握好；
- 策略逻辑要尽量简化。

我们不知道级别 C 和新的计算逻辑谁先出现，或许他们都不会出现，所以在不知道新需求的方式时当前够用的就是最好的，如果有新的计算逻辑可以这样改造上面函数：
 
    function calculateBonus(performanceLevel, salary) {
        var config = {
            A: handler: function () {
                return 3 * salary;
            }
        };

        var item = config[performanceLevel];
        // 这里省去了对参数的校验...
        
        return item.handler();
    }

没有最好的代码，只有最适合的代码。用配置的方式组织策略，简单到可能认不出这是策略模式。在策略模式中根据策略的异同点来抽象策略的组织是此模式的关键。

## 代理模式

定义：为一个对象提供一个代用品或占位符，以便控制对他的访问。

代理的主要目的是增强原有对象，增强的方式是用户通过访问代理对象，代理对象为被代理对象实现一部分功能。代理有三个比较好的应用场景：

- 为特定场景定制原对象，使调用更简单(将原对象的一些接口固化)；
- 将某些场景的通用逻辑封装到代理中，减少重复代码；
- 使依赖反转，方便偷梁换柱(这在切换库函数时尤为有效)

## 迭代器模式

在 ES5 中此模式已经有了很好的支持，如数组原生支持 `forEach` `reduce` 等常规迭代模式，扩展的还有 `some` `every` `reduceRight` `map` `filter` 这些，所以此模式在 js 中可以略去。

## 发布-订阅模式(观察者模式)

定义：它定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖它的其他对象都将得到通知。

此模式有三个层级的实现：

一、模拟 Dom 事件，订阅者对发布者有依赖，订阅者很轻只有响应逻辑，要求发布者先存在，经典代码如下：

    document.getElementById('id').addEventListener('click', function () {
        // 响应逻辑
    });

二、全局模式，发布者成为了一个单例，当然这个单例需要出现在订阅和发布之前，任何对象都可以订阅事件，在代码的任何地方都可以触发发布，好处在于方便，但坏处是事件可以满天飞，需要解决命名冲突的问题，书中给出的 `create('namespace')` 方案不是很优雅，这里斗胆提另一种方案：

    Event.listen({
        scope: 'namespace',
        name: 'click',
        handler: function () {
            // 响应逻辑，也可以把此函数放在对象后作为单独的参数
        }
    });

通过第一个参数类型来判断需不需要走命名空间。这种全局的发布-订阅模式在早期的粗放式开发中可能会用到，但是在今天到处模块化的今天还是用下面的模式比较好。

三、这种是前两种的结合类型，在组件中提供冒泡和广播机制，页面由组件组成，最上面有一个根组件(类似于 Dom 结构的 body)，下面组件通过符合排列等方式组成页面，事件的发布只能向上或向下，这样在一条组件链上天然形成了作用域分割。这种模式有一个缺点，当相邻组件需要通过发布-订阅通信时需要借助他们共同的父组件才能实现，Vue 1.x 就是用的此种模式。

从解耦的角度来看第一种方法使发布者不依赖订阅者，第二种方法使发布者和订阅者相互不依赖但但产生了作用域的问题，第三种方式通过 Dom 树的天然分支特性来分割作用域。

## 命令模式

在 js 中这个模式已经融入到语法特性中，可用回调更方便的实现此模式的目标。


