<!DOCTYPE html>
<html>
<head lang="zh-cn">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>React 官方文档 - 入门教程 - 龙则的个人站点</title>
    <script>
        // 用户通过搜索引擎到文章详情页时，跳到首页并进行哈希路由
        var href = window.location.href.replace(/[^:|\/]\//,function (matchStr){
            return matchStr + 'index.html#!';
        });
        window.location.href = href.replace('/main.html', '');
    </script>
</head>
<body>
<header>
    <h1> 龙则的个人站点 </h1>
    <h2> 精进自己，服务他人 </h2>
</header>
<div>
    <h1 id="header-1">React 官方文档 - 入门教程</h1>
<h2 id="header-1-1">JSFiddle</h2>
<p>开始 Hack React 的最简单的方法是用下面 JSFiddle 的Hello Worlds：</p>
<ul>
<li><strong><a href="https://jsfiddle.net/reactjs/69z2wepo/" target="_blank">React JSFiddle</a></strong></li>
<li><a href="https://jsfiddle.net/reactjs/5vjqabv3/" target="_blank">React JSFiddle without JSX</a></li>
</ul>
<h2 id="header-1-2">通过 npm 使用 React</h2>
<p>我们建议在 React 中使用 CommonJS 模块系统，比如 <a href="http://browserify.org/" target="_blank">browserify</a> 或 <a href="https://webpack.github.io/" target="_blank">webpack</a>。使用 <a href="https://www.npmjs.com/package/react" target="_blank"><code>react</code></a> 和 <a href="https://www.npmjs.com/package/react-dom" target="_blank"><code>react-dom</code></a> npm 包.</p>
<pre><code class="lang-js">// main.js
var React = require(&#39;react&#39;);
var ReactDOM = require(&#39;react-dom&#39;);

ReactDOM.render(
  &lt;h1&gt;Hello, world!&lt;/h1&gt;,
  document.getElementById(&#39;example&#39;)
);
</code></pre>
<p>要用 browserify 安装 React DOM 和构建你的包。</p>
<pre><code class="lang-sh">$ npm install --save react react-dom babelify babel-preset-react
$ browserify -t [ babelify --presets [ react ] ] main.js -o bundle.js
</code></pre>
<p>要用 webpack 安装 React DOM 和构建你的包:  </p>
<pre><code class="lang-sh">$ npm install --save react react-dom babel-preset-react
$ webpack
</code></pre>
<blockquote>
<p>注意:</p>
<p>如果你正在使用 ES2015, 你将要使用 <code>babel-preset-es2015</code> 包.</p>
</blockquote>
<p><strong>注意:</strong> 默认情况下，React 将会在开发模式，很缓慢，不建议用于生产。要在生产模式下使用 React，设置环境变量 <code>NODE_ENV</code> 为 <code>production</code> （使用 envify 或者 webpack&#39;s DefinePlugin）。例如：</p>
<pre><code class="lang-js">new webpack.DefinePlugin({
  &quot;process.env&quot;: {
    NODE_ENV: JSON.stringify(&quot;production&quot;)
  }
});
</code></pre>
<h2 id="header-1-3">不用 npm 的快速开始</h2>
<p>如果你现在还没准备要使用npm,你可以下载这个已经包含了预构建的 React 和 React DOM 拷贝的入门套件. </p>
<div class="buttons-unit downloads">
  <a href="/react/downloads/react-{{site.react_version}}.zip" class="button">
    下载入门套件 {{site.react_version}}
  </a>
</div>

<p>在入门教程包的根目录，创建一个含有如下代码的 <code>helloworld.html</code>。</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;Hello React!&lt;/title&gt;
    &lt;script src=&quot;build/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;build/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://unpkg.com/babel-core@5.8.38/browser.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
      ReactDOM.render(
        &lt;h1&gt;Hello, world!&lt;/h1&gt;,
        document.getElementById(&#39;example&#39;)
      );
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在 JavaScript 代码里写着 XML 格式的代码称为 JSX；可以去 <a href="/react/docs/jsx-in-depth.html" target="_blank">JSX 语法</a> 里学习更多 JSX 相关的知识。为了把 JSX 转成标准的 JavaScript，我们用 <code>&lt;script type=&quot;text/babel&quot;&gt;</code> 标签，并引入 Babel 来完成在浏览器里的代码转换。在浏览器里打开这个html，你应该可以看到成功的消息！</p>
<h3 id="header-1-3-1">分离文件</h3>
<p>你的 React JSX 代码文件可以写在另外的文件里。新建下面的 <code>src/helloworld.js</code>。</p>
<pre><code class="lang-javascript">ReactDOM.render(
  &lt;h1&gt;Hello, world!&lt;/h1&gt;,
  document.getElementById(&#39;example&#39;)
);
</code></pre>
<p>然后在 <code>helloworld.html</code> 引用该文件：</p>
<pre><code class="lang-html{10}">&lt;script type=&quot;text/babel&quot; src=&quot;src/helloworld.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>注意一些浏览器（比如 Chrome ）会在使用 HTTP 以外的协议加载文件时失败。</p>
<h3 id="header-1-3-2">离线转换</h3>
<p>先安装<a href="http://babeljs.io/" target="_blank">Babel</a>命令行工具（需要 <a href="https://www.npmjs.com/" target="_blank">npm</a>）：</p>
<pre><code>npm install --global babel-cli
npm install babel-preset-react
</code></pre><p>然后把你的 <code>src/helloworld.js</code> 文件转成标准的 JavaScript:</p>
<pre><code>babel --presets react src --watch --out-dir build
</code></pre><blockquote>
<p>注意:</p>
<p>如果你正在使用 ES2015, 你将需要使用 <code>babel-preset-es2015</code> 包.</p>
</blockquote>
<p><code>build/helloworld.js</code> 会在你对文件进行修改时自动生成。 阅读 <a href="http://babeljs.io/docs/usage/cli/" target="_blank">Babel CLI 文档</a> 了解高级用法。</p>
<pre><code class="lang-javascript{2}">ReactDOM.render(
  React.createElement(&#39;h1&#39;, null, &#39;Hello, world!&#39;),
  document.getElementById(&#39;example&#39;)
);
</code></pre>
<p>对照下面更新你的 HTML 代码</p>
<pre><code class="lang-html{8,12}">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;Hello React!&lt;/title&gt;
    &lt;script src=&quot;build/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;build/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;!-- 不需要 Babel! --&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;example&quot;&gt;&lt;/div&gt;
    &lt;script src=&quot;build/helloworld.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="header-1-4">下一步</h2>
<p>去看看<a href="/react/docs/tutorial.html" target="_blank">入门教程</a> 和入门教程包 <code>examples</code> 目录下的其它例子学习更多。</p>
<p>我们还有一个社区开发者共建的 Wiki：<a href="https://github.com/facebook/react/wiki/Complementary-Tools" target="_blank">workflows, UI-components, routing, data management etc.</a></p>
<p>恭喜你，欢迎来到 React 的世界。</p>
<h2 id="header-1-5">文档导航</h2>
<p>入门教程
实例指导</p>
<p>我们将建立一个你可以放进博客的简单却真实的评论框，一个 Disqus、LiveFyre 或 Facebook comments 提供的实时评论的基础版本。</p>
<p>我们将提供：</p>
<ul>
<li>一个所有评论的视图</li>
<li>一个用于提交评论的表单</li>
<li>为你提供制定后台的挂钩(Hooks)</li>
</ul>
<p>同时也会有一些简洁的功能：</p>
<ul>
<li><strong>优化的评论：</strong> 评论在它们保存到服务器之前就显示在列表里,所以感觉很快。</li>
<li><strong>实时更新：</strong> 其他用户的评论被实时浮现到评论中。</li>
<li><strong>Markdown格式化：</strong> 用户可以用Markdown格式化它们的文字。</li>
</ul>
<h3 id="header-1-5-1">想要跳过所有内容，只查看源代码？</h3>
<p><a href="https://github.com/reactjs/react-tutorial" target="_blank">全在 GitHub .</a></p>
<h3 id="header-1-5-2">运行服务器</h3>
<p>为了开始本教程，我们将要需要一个运行着的服务器。这将是我们纯粹用来获取和保存数据的伺服终端。为了让这尽可能的容易，我们已经用许多不同的语言编写了简单的服务器，它正好完成我们需要的事。    <strong>你可以<a href="https://github.com/reactjs/react-tutorial/" target="_blank">查看源代码</a> 或者 <a href="https://github.com/reactjs/react-tutorial/archive/master.zip" target="_blank">下载 zip 文件</a> 包括了所有你开始学习需要的东西</strong></p>
<p>为了简单起见，我们将要运行的服务器使用 <code>JSON</code> 文件作为数据库。你不会在生产环境运行这个，但是它让我们更容易模拟使用一个API时你可能会做的事。一旦你启动服务器，它将会支持我们的API终端,同时也将伺服我们需要的静态页面。</p>
<h3 id="header-1-5-3">开始</h3>
<p>对于此教程,我们将使它尽可能的容易。被包括在上面讨论的服务器包里的是一个我们将在其中工作的 HTML 文件。在你最喜欢的编辑器里打开 <code>public/index.html</code>。它应该看起来像这样 （可能有一些小的不同，稍后我们将添加一个额外的 <code>&lt;script&gt;</code> 标签）：</p>
<pre><code class="lang-html">&lt;!-- index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;React Tutorial&lt;/title&gt;
    &lt;script src=&quot;https://unpkg.com/react@{{site.react_version}}/dist/react.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://unpkg.com/react-dom@{{site.react_version}}/dist/react-dom.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://unpkg.com/babel-core@5.8.38/browser.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://unpkg.com/jquery@3.1.0/dist/jquery.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://unpkg.com/remarkable@1.6.2/dist/remarkable.min.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;content&quot;&gt;&lt;/div&gt;
    &lt;script type=&quot;text/babel&quot; src=&quot;scripts/example.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/babel&quot;&gt;
      // To get started with this tutorial running your own code, simply remove
      // the script tag loading scripts/example.js and start writing code here.
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>在本教程剩余的部分，我们将在此 script 标签中编写我们的 JavaScript 代码。我们没有任何高级的实时加载所以在保存以后你需要刷新你的浏览器来观察更新。通过在浏览器打开 <code>http://localhost:3000</code> 关注你的进展。当你没有任何修改第一次加载时，你将看到我们将要准备建立的已经完成的产品。当你准备开始工作，请删除前面的 <code>&lt;script&gt;</code> 标签然后你就可以继续了。</p>
<blockquote>
<p>注意：</p>
<p>我们在这里引入 jQuery 是因为我们想简化我们未来的 ajax 请求，但这对React的正常工作 <strong>不是</strong> 必要的。</p>
</blockquote>
<h3 id="header-1-5-4">你的第一个组件</h3>
<p>React 中都是关于模块化、可组装的组件。以我们的评论框为例，我们将有如下的组件结构：</p>
<pre><code>- CommentBox
  - CommentList
    - Comment
  - CommentForm
</code></pre><p>让我们构造 <code>CommentBox</code> 组件，仅是一个简单的 <code>&lt;div&gt;</code> ：</p>
<pre><code class="lang-javascript">// tutorial1.js
var CommentBox = React.createClass({
  render: function() {
    return (
      &lt;div className=&quot;commentBox&quot;&gt;
        Hello, world! I am a CommentBox.
      &lt;/div&gt;
    );
  }
});
ReactDOM.render(
  &lt;CommentBox /&gt;,
  document.getElementById(&#39;content&#39;)
);
</code></pre>
<p>注意原生的HTML元素以小写开头，而制定的 React 类以大写开头。</p>
<h4 id="header-1-5-4-1">JSX 语法</h4>
<p>首先你会注意到你的 JavaScript 中 XML 式的语法。我们有一个简单的预编译器，将语法糖转换成这种纯的JavaScript：</p>
<pre><code class="lang-javascript">// tutorial1-raw.js
var CommentBox = React.createClass({displayName: &#39;CommentBox&#39;,
  render: function() {
    return (
      React.createElement(&#39;div&#39;, {className: &quot;commentBox&quot;},
        &quot;Hello, world! I am a CommentBox.&quot;
      )
    );
  }
});
ReactDOM.render(
  React.createElement(CommentBox, null),
  document.getElementById(&#39;content&#39;)
);
</code></pre>
<p>它的使用是可选的，但是我们发现 JSX 语法比单纯的 JavaScript 更加容易使用。阅读更多关于<a href="/react/docs/jsx-in-depth-zh-CN.html" target="_blank">JSX 语法的文章</a>。</p>
<h4 id="header-1-5-4-2">What&#39;s going on</h4>
<p>我们在一个 JavaScript 对象中传递一些方法到 <code>React.createClass()</code> 来创建一个新的React组件。这些方法中最重要的是 <code>render</code>，该方法返回一颗 React 组件树，这棵树最终将会渲染成 HTML。</p>
<p>这个 <code>&lt;div&gt;</code> 标签不是真实的DOM节点；他们是 React <code>div</code> 组件的实例化。你可以把这些看做是React知道如何处理的标记或者是一些数据 。React 是<strong>安全的</strong>。我们不生成 HTML 字符串，因此XSS防护是默认特性。</p>
<p>你没有必要返回基本的 HTML。你可以返回一个你（或者其他人）创建的组件树。这就使 React <strong>组件化</strong>：一个可维护前端的关键原则。</p>
<p><code>ReactDOM.render()</code> 实例化根组件，启动框架，注入标记到原始的 DOM 元素中，作为第二个参数提供。</p>
<p><code>ReactDOM</code> 模块暴露了 DOM 相关的方法， 而 <code>React</code> 保有被不同平台的 React 共享的核心工具 （例如 <a href="http://facebook.github.io/react-native/" target="_blank">React Native</a>）。</p>
<p>对于本教程 <code>ReactDOM.render</code> 保持在脚本底部是很重要的。<code>ReactDOM.render</code> 应该只在复合组件被定义之后被调用。</p>
<h2 id="header-1-6">组合组件</h2>
<p>让我们为 <code>CommentList</code> 和 <code>CommentForm</code> 建造骨架，它们将会，再一次的，是一些简单的 <code>&lt;div&gt;</code>。添加这两个组件到你的文件里，保持现存的 <code>CommentBox</code> 声明和 <code>ReactDOM.render</code> 调用:</p>
<pre><code class="lang-javascript">// tutorial2.js
var CommentList = React.createClass({
  render: function() {
    return (
      &lt;div className=&quot;commentList&quot;&gt;
        Hello, world! I am a CommentList.
      &lt;/div&gt;
    );
  }
});

var CommentForm = React.createClass({
  render: function() {
    return (
      &lt;div className=&quot;commentForm&quot;&gt;
        Hello, world! I am a CommentForm.
      &lt;/div&gt;
    );
  }
});
</code></pre>
<p>接着，更新 <code>CommentBox</code> 以使用这些新的组件：</p>
<pre><code class="lang-javascript{6-8}">// tutorial3.js
var CommentBox = React.createClass({
  render: function() {
    return (
      &lt;div className=&quot;commentBox&quot;&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList /&gt;
        &lt;CommentForm /&gt;
      &lt;/div&gt;
    );
  }
});
</code></pre>
<p>注意我们是如何混合 HTML 标签和我们建立的组件。HTML 组件是正常的 React 组件，就和你定义的一样，只有一个区别。JSX 编译器会自动重写 HTML 标签为 <code>React.createElement(tagName)</code> 表达式，其它什么都不做。这是为了避免污染全局命名空间。</p>
<h3 id="header-1-6-1">使用 props</h3>
<p>让我们创建 <code>Comment</code> 组件，它将依赖于从父级传来的数据。从父级传来的数据在子组件里作为 &#39;属性&#39; 可供使用。 这些 &#39;属性&#39; 可以通过 <code>this.props</code> 访问。使用属性，我们将能读取从 <code>CommentList</code> 传递给 <code>Comment</code> 的数据，并且渲染一些标记：</p>
<pre><code class="lang-javascript">// tutorial4.js
var Comment = React.createClass({
  render: function() {
    return (
      &lt;div className=&quot;comment&quot;&gt;
        &lt;h2 className=&quot;commentAuthor&quot;&gt;
          {this.props.author}
        &lt;/h2&gt;
        {this.props.children}
      &lt;/div&gt;
    );
  }
});
</code></pre>
<p>在 JSX 中,通过将 JavaScript 表达式放在大括号中（作为属性或者子节点）,你可以把文本或者 React 组件放置到树中。我们以 <code>this.props</code> 的 keys 访问传递给组件的命名属性，以 <code>this.props.children</code> 访问任何嵌套的元素。</p>
<h3 id="header-1-6-2">组件的属性</h3>
<p>既然我们已经定义了 <code>Comment</code> 组件，我们将要传递作者名和评论文字给它。这允许我们为每个评论重用相同的代码。现在让我们在我们的 <code>CommentList</code> 里添加一些评论。</p>
<pre><code class="lang-javascript{6-7}">// tutorial5.js
var CommentList = React.createClass({
  render: function() {
    return (
      &lt;div className=&quot;commentList&quot;&gt;
        &lt;Comment author=&quot;Pete Hunt&quot;&gt;This is one comment&lt;/Comment&gt;
        &lt;Comment author=&quot;Jordan Walke&quot;&gt;This is *another* comment&lt;/Comment&gt;
      &lt;/div&gt;
    );
  }
});
</code></pre>
<p>注意，我们已经从 <code>CommentList</code>  组件传递了一些数据到 <code>Comment</code> 组件。例如，我们传递了 <em>Pete Hunt</em> （通过属性）和 <em>This is one comment</em> (通过 XML-风格的子节点)给第一个 <code>Comment</code>。如上面提到的那样， <code>Comment</code> 组件将会通过 <code>this.props.author</code> 和 <code>this.props.children</code> 访问 这些 &#39;属性&#39;。</p>
<h3 id="header-1-6-3">添加 Markdown</h3>
<p>Markdown 是一种简单的内联格式化你的文字的方法。例如，用星号包围文本将会使其强调突出。</p>
<p>在本教程中我们使用第三方库 <strong>remarkable</strong>，它接受 Markdown 文本并且转换为原始的 HTML。我们已经在初始的页面标记里包含了这个库，所以我们可以直接开始使用它，让我们转换评论文本为 Markdown 并输出它：</p>
<pre><code class="lang-javascript{4,10}">// tutorial6.js
var Comment = React.createClass({
  render: function() {
    var md = new Remarkable();
    return (
      &lt;div className=&quot;comment&quot;&gt;
        &lt;h2 className=&quot;commentAuthor&quot;&gt;
          {this.props.author}
        &lt;/h2&gt;
        {md.render(this.props.children.toString())}
      &lt;/div&gt;
    );
  }
});
</code></pre>
<p>我们在这里唯一做的就是调用 remarkable 库。我们需要把 从 React 的包裹文本来的 <code>this.props.children</code> 转换成 remarkable 能理解的原始字符串，所以我们显示地调用了<code>toString()</code>。</p>
<p>但是这里有一个问题！我们渲染的评论在浏览器里看起来像这样： &quot;<code>&lt;p&gt;</code>This is <code>&lt;em&gt;</code>another<code>&lt;/em&gt;</code> comment<code>&lt;/p&gt;</code>&quot; 。我们想让这些标签真正地渲染为 HTML。</p>
<p>那是 React 在保护你免受 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank">XSS 攻击</a>。有一个方法解决这个问题，但是框架会警告你别使用这种方法：</p>
<pre><code class="lang-javascript{3-7,15}">// tutorial7.js
var Comment = React.createClass({
  rawMarkup: function() {
    var md = new Remarkable();
    var rawMarkup = md.render(this.props.children.toString());
    return { __html: rawMarkup };
  },

  render: function() {
    return (
      &lt;div className=&quot;comment&quot;&gt;
        &lt;h2 className=&quot;commentAuthor&quot;&gt;
          {this.props.author}
        &lt;/h2&gt;
        &lt;span dangerouslySetInnerHTML={this.rawMarkup()} /&gt;
      &lt;/div&gt;
    );
  }
});
</code></pre>
<p>这是一个特殊的 API，故意让插入原始的 HTML 变得困难，但是对于 remarkable 我们将利用这个后门。</p>
<p><strong>记住：</strong> 使用这个功能你会依赖于 remarkable 是安全的。</p>
<h3 id="header-1-6-4">挂钩数据模型</h3>
<p>到目前为止我们已经完成了在源码里直接插入评论。作为替代，让我们渲染一团 JSON 数据到评论列表里。最终数据将会来自服务器，但是现在，写在你的源代码中：</p>
<pre><code class="lang-javascript">// tutorial8.js
var data = [
  {id: 1, author: &quot;Pete Hunt&quot;, text: &quot;This is one comment&quot;},
  {id: 2, author: &quot;Jordan Walke&quot;, text: &quot;This is *another* comment&quot;}
];
</code></pre>
<p>我们需要以一种模块化的方式将这个数据传入到 <code>CommentList</code>。修改 <code>CommentBox</code> 和 <code>ReactDOM.render()</code> 方法，以便于通过 props 传入数据到 <code>CommentList</code>：</p>
<pre><code class="lang-javascript{7,15}">// tutorial9.js
var CommentBox = React.createClass({
  render: function() {
    return (
      &lt;div className=&quot;commentBox&quot;&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList data={this.props.data} /&gt;
        &lt;CommentForm /&gt;
      &lt;/div&gt;
    );
  }
});

ReactDOM.render(
  &lt;CommentBox data={data} /&gt;,
  document.getElementById(&#39;content&#39;)
);
</code></pre>
<p>既然现在数据在 <code>CommentList</code> 中可用了，让我们动态地渲染评论：</p>
<pre><code class="lang-javascript{4-10,13}">// tutorial10.js
var CommentList = React.createClass({
  render: function() {
    var commentNodes = this.props.data.map(function(comment) {
      return (
        &lt;Comment author={comment.author} key={comment.id}&gt;
          {comment.text}
        &lt;/Comment&gt;
      );
    });
    return (
      &lt;div className=&quot;commentList&quot;&gt;
        {commentNodes}
      &lt;/div&gt;
    );
  }
});
</code></pre>
<p>就是这样！</p>
<h3 id="header-1-6-5">从服务器获取数据</h3>
<p>让我们用一些来自服务器的动态数据替换硬编码的数据。我们将移除数据的prop，用获取数据的URL来替换它：</p>
<pre><code class="lang-javascript{3}">// tutorial11.js
ReactDOM.render(
  &lt;CommentBox url=&quot;/api/comments&quot; /&gt;,
  document.getElementById(&#39;content&#39;)
);
</code></pre>
<p>这个组件不同于和前面的组件，因为它必须重新渲染自己。该组件将不会有任何数据，直到请求从服务器返回，此时该组件或许需要渲染一些新的评论。</p>
<p>注意： 此代码在这个阶段不会工作。</p>
<h3 id="header-1-6-6">Reactive state</h3>
<p>迄今为止,基于它自己的props，每个组件都渲染了自己一次。<code>props</code> 是不可变的：它们从父级传来并被父级“拥有”。为了实现交互，我们给组件引进了可变的 <strong>state</strong>。<code>this.state</code> 是组件私有的，可以通过调用 <code>this.setState()</code> 改变它。每当state更新，组件就重新渲染自己。</p>
<p><code>render()</code> 方法被声明为一个带有 <code>this.props</code> 和 <code>this.state</code> 的函数。框架保证了 UI 总是与输入一致。</p>
<p>当服务器获取数据时，我们将会改变我们已有的评论数据。让我们给 <code>CommentBox</code> 组件添加一组评论数据作为它的状态：</p>
<pre><code class="lang-javascript{3-5,10}">// tutorial12.js
var CommentBox = React.createClass({
  getInitialState: function() {
    return {data: []};
  },
  render: function() {
    return (
      &lt;div className=&quot;commentBox&quot;&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList data={this.state.data} /&gt;
        &lt;CommentForm /&gt;
      &lt;/div&gt;
    );
  }
});
</code></pre>
<p><code>getInitialState()</code> 在生命周期里只执行一次，并设置组件的初始状态。</p>
<h4 id="header-1-6-6-1">更新状态</h4>
<p>当组件第一次创建时，我们想从服务器获取一些 JSON 并且更新状态以反映最新的数据。我们将用 jQuery 来发送一个异步请求到我们刚才启动的服务器以获取我们需要的数据。这些数据已经被包含在了你已启动的服务器里（基于<code>comments.json</code>文件），所以一旦被获取，<code>this.state.data</code> 会看起来像这样：</p>
<pre><code class="lang-json">[
  {&quot;author&quot;: &quot;Pete Hunt&quot;, &quot;text&quot;: &quot;This is one comment&quot;},
  {&quot;author&quot;: &quot;Jordan Walke&quot;, &quot;text&quot;: &quot;This is *another* comment&quot;}
]
</code></pre>
<pre><code class="lang-javascript{6-18}">// tutorial13.js
var CommentBox = React.createClass({
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  render: function() {
    return (
      &lt;div className=&quot;commentBox&quot;&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList data={this.state.data} /&gt;
        &lt;CommentForm /&gt;
      &lt;/div&gt;
    );
  }
});
</code></pre>
<p>这里， <code>componentDidMount</code> 是一个当组件被渲染时被Ｒeact自动调用的方法。动态更新的关键是对 <code>this.setState()</code> 的调用。我们用新的从服务器来的替换掉旧的评论组，然后UI自动更新自己。因为这种反应性，仅是一个微小的变化就添加了实时更新。我们这里将用简单的轮询，但是你可以容易的使用 WebSockets 或者其他技术。</p>
<pre><code class="lang-javascript{3,15,20-21,35}">// tutorial14.js
var CommentBox = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    return (
      &lt;div className=&quot;commentBox&quot;&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList data={this.state.data} /&gt;
        &lt;CommentForm /&gt;
      &lt;/div&gt;
    );
  }
});

ReactDOM.render(
  &lt;CommentBox url=&quot;/api/comments&quot; pollInterval={2000} /&gt;,
  document.getElementById(&#39;content&#39;)
);
</code></pre>
<p>我们在这里做的全部事情是把 AJAX 调用移动到独立的方法里，然后在组件第一次加载时及其后每2秒 调用它。试着在你的浏览器里运行它并且改变 <code>comments.json</code> 文件（在你的服务器的相同目录）；2秒内，变化将会显现！</p>
<h3 id="header-1-6-7">添加新评论</h3>
<p>现在是时候建立表单了，我们的 <code>CommentForm</code> 组件应该询问用户他们的名字和评论文本然后发送一个请求到服务器来保存评论.</p>
<pre><code class="lang-javascript{5-9}">// tutorial15.js
var CommentForm = React.createClass({
  render: function() {
    return (
      &lt;form className=&quot;commentForm&quot;&gt;
        &lt;input type=&quot;text&quot; placeholder=&quot;Your name&quot; /&gt;
        &lt;input type=&quot;text&quot; placeholder=&quot;Say something...&quot; /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Post&quot; /&gt;
      &lt;/form&gt;
    );
  }
});
</code></pre>
<h4 id="header-1-6-7-1">受控组件</h4>
<p>对于传统的 DOM， <code>input</code> 元素被渲染并且浏览器管理它的状态（它的渲染值）。结果是，DOM的实际值会和组件不同。这是不理想的，因为视图的值会和组件的值不同。在React中，组件应该总是表示视图的值而不只是在初始化时。</p>
<p>因此，我们将使用 <code>this.state</code> 来在用户输入时保存输入。我们定义一个初始 <code>state</code>，它带有 <code>author</code> 和 <code>text</code> 两个属性并将他们设置为空字符串。在我们的 <code>&lt;input&gt;</code> 元素里，我们设置 <code>value</code> prop 来反映组件的 <code>state</code> 并给他们附加 <code>onChange</code> 事件处理。这些带有设置了 <code>value</code> 的  <code>&lt;input&gt;</code> 元素被称为受控组件。更多关于受控组件请阅读 <a href="/react/docs/forms.html#controlled-components" target="_blank">Forms article</a>。</p>
<pre><code class="lang-javascript{3-11,15-26}">// tutorial16.js
var CommentForm = React.createClass({
  getInitialState: function() {
    return {author: &#39;&#39;, text: &#39;&#39;};
  },
  handleAuthorChange: function(e) {
    this.setState({author: e.target.value});
  },
  handleTextChange: function(e) {
    this.setState({text: e.target.value});
  },
  render: function() {
    return (
      &lt;form className=&quot;commentForm&quot;&gt;
        &lt;input
          type=&quot;text&quot;
          placeholder=&quot;Your name&quot;
          value={this.state.author}
          onChange={this.handleAuthorChange}
        /&gt;
        &lt;input
          type=&quot;text&quot;
          placeholder=&quot;Say something...&quot;
          value={this.state.text}
          onChange={this.handleTextChange}
        /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Post&quot; /&gt;
      &lt;/form&gt;
    );
  }
});
</code></pre>
<h5 id="header-1-6-7-1-1">事件</h5>
<p>React使用小驼峰命名规范(camelCase)给组件绑定事件处理器。我们附加 <code>onChange</code> 给两个 <code>&lt;input&gt;</code> 元素。现在，当用户输入文本到 <code>&lt;input&gt;</code> 中，被附加的 <code>onChange</code> 回调函数被激发并且组件的 <code>state</code> 被修改。然后，被渲染的 <code>input</code> 元素的值将会更新以反映当前组件的 <code>state</code>。</p>
<h4 id="header-1-6-7-2">提交表单</h4>
<p>让我们使表单具有交互性。当用户提交表单时，我们应该清除它，提交一个请求到服务器，并刷新评论列表。让我们监听表单的提交事件并清除它。</p>
<pre><code class="lang-javascript{12-21,24}">// tutorial17.js
var CommentForm = React.createClass({
  getInitialState: function() {
    return {author: &#39;&#39;, text: &#39;&#39;};
  },
  handleAuthorChange: function(e) {
    this.setState({author: e.target.value});
  },
  handleTextChange: function(e) {
    this.setState({text: e.target.value});
  },
  handleSubmit: function(e) {
    e.preventDefault();
    var author = this.state.author.trim();
    var text = this.state.text.trim();
    if (!text || !author) {
      return;
    }
    // TODO: send request to the server
    this.setState({author: &#39;&#39;, text: &#39;&#39;});
  },
  render: function() {
    return (
      &lt;form className=&quot;commentForm&quot; onSubmit={this.handleSubmit}&gt;
        &lt;input
          type=&quot;text&quot;
          placeholder=&quot;Your name&quot;
          value={this.state.author}
          onChange={this.handleAuthorChange}
        /&gt;
        &lt;input
          type=&quot;text&quot;
          placeholder=&quot;Say something...&quot;
          value={this.state.text}
          onChange={this.handleTextChange}
        /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Post&quot; /&gt;
      &lt;/form&gt;
    );
  }
});
</code></pre>
<p>我们给表单绑定一个<code>onSubmit</code>处理器，它在表单提交了合法的输入后清空表单字段。</p>
<p>在事件中调用<code>preventDefault()</code>来阻止浏览器提交表单的默认行为。</p>
<h5 id="header-1-6-7-2-1">回调函数作为属性</h5>
<p>当用户提交评论时，我们需要刷新评论列表来包含这条新评论。在<code>CommentBox</code>中完成所有逻辑是有道理的，因为<code>CommentBox</code> 拥有代表了评论列表的状态(state)。</p>
<p>我们需要从子组件传回数据到它的父组件。我们在父组件的<code>render</code>方法中以传递一个新的回调函数（<code>handleCommentSubmit</code>）到子组件完成这件事，绑定它到子组件的 <code>onCommentSubmit</code> 事件上。无论事件什么时候触发，回调函数都将被调用：</p>
<pre><code class="lang-javascript{16-18,31}">// tutorial18.js
var CommentBox = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  handleCommentSubmit: function(comment) {
    // TODO: submit to the server and refresh the list
  },
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    return (
      &lt;div className=&quot;commentBox&quot;&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList data={this.state.data} /&gt;
        &lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&gt;
      &lt;/div&gt;
    );
  }
});
</code></pre>
<p>既然 <code>CommentBox</code> 已经通过 <code>onCommentSubmit</code> prop 使回调函数对于 <code>CommentForm</code> 可用，<code>CommentForm</code> 就可以在用户提交表单时调用回调函数：</p>
<pre><code class="lang-javascript{19}">// tutorial19.js
var CommentForm = React.createClass({
  getInitialState: function() {
    return {author: &#39;&#39;, text: &#39;&#39;};
  },
  handleAuthorChange: function(e) {
    this.setState({author: e.target.value});
  },
  handleTextChange: function(e) {
    this.setState({text: e.target.value});
  },
  handleSubmit: function(e) {
    e.preventDefault();
    var author = this.state.author.trim();
    var text = this.state.text.trim();
    if (!text || !author) {
      return;
    }
    this.props.onCommentSubmit({author: author, text: text});
    this.setState({author: &#39;&#39;, text: &#39;&#39;});
  },
  render: function() {
    return (
      &lt;form className=&quot;commentForm&quot; onSubmit={this.handleSubmit}&gt;
        &lt;input
          type=&quot;text&quot;
          placeholder=&quot;Your name&quot;
          value={this.state.author}
          onChange={this.handleAuthorChange}
        /&gt;
        &lt;input
          type=&quot;text&quot;
          placeholder=&quot;Say something...&quot;
          value={this.state.text}
          onChange={this.handleTextChange}
        /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Post&quot; /&gt;
      &lt;/form&gt;
    );
  }
});
</code></pre>
<p>既然现在回调函数已经就绪，我们所需要做的就是提交到服务器然后刷新列表：</p>
<pre><code class="lang-javascript{17-28}">// tutorial20.js
var CommentBox = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  handleCommentSubmit: function(comment) {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      type: &#39;POST&#39;,
      data: comment,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    return (
      &lt;div className=&quot;commentBox&quot;&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList data={this.state.data} /&gt;
        &lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&gt;
      &lt;/div&gt;
    );
  }
});
</code></pre>
<h3 id="header-1-6-8">优化: 优化的更新</h3>
<p>我们的应用现在已经功能完备，但是它感觉很慢，因为在评论出现在列表前必须等待请求完成。我们可以优化添加这条评论到列表以使应用感觉更快。</p>
<pre><code class="lang-javascript{17-23,33}">// tutorial21.js
var CommentBox = React.createClass({
  loadCommentsFromServer: function() {
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      cache: false,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  handleCommentSubmit: function(comment) {
    var comments = this.state.data;
    // Optimistically set an id on the new comment. It will be replaced by an
    // id generated by the server. In a production application you would likely
    // not use Date.now() for this and would have a more robust system in place.
    comment.id = Date.now();
    var newComments = comments.concat([comment]);
    this.setState({data: newComments});
    $.ajax({
      url: this.props.url,
      dataType: &#39;json&#39;,
      type: &#39;POST&#39;,
      data: comment,
      success: function(data) {
        this.setState({data: data});
      }.bind(this),
      error: function(xhr, status, err) {
        this.setState({data: comments});
        console.error(this.props.url, status, err.toString());
      }.bind(this)
    });
  },
  getInitialState: function() {
    return {data: []};
  },
  componentDidMount: function() {
    this.loadCommentsFromServer();
    setInterval(this.loadCommentsFromServer, this.props.pollInterval);
  },
  render: function() {
    return (
      &lt;div className=&quot;commentBox&quot;&gt;
        &lt;h1&gt;Comments&lt;/h1&gt;
        &lt;CommentList data={this.state.data} /&gt;
        &lt;CommentForm onCommentSubmit={this.handleCommentSubmit} /&gt;
      &lt;/div&gt;
    );
  }
});
</code></pre>
<h3 id="header-1-6-9">祝贺!</h3>
<p>你刚刚通过几个简单的步骤建立了一个评论框。学习更多关于<a href="/react/docs/why-react-zh-CN.html" target="_blank">为什么使用 React</a>, 或者深入 <a href="/react/docs/top-level-api.html" target="_blank">API 参考</a> 开始钻研！祝你好运！</p>

</div>
</body>
</html>