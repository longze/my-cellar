# 服务器端渲染的几点说明和注意

> 服务器端渲染简称 SSR(server side render)，就是在服务器端将数据和 HTML 融合后返回给浏览器，那这和多年前的 JSP 不是一样了吗，是换个轮胎开倒车吗？

## 概述

技术方案的存在都是为了解决问题，JSP 方案因为一些问题被前后端分离的整站 Ajax 方案代替，整站 Ajax 又因为一些问题可能要被 SSR 代替。

关于前后端分离的话题这里不展开，这一趴重点谈谈整站 Ajax 有什么问题，SSR 又是怎么解决的。

## SEO

“搜索引擎优化” 简称 “SEO（Search Engine Optimization）”，互联网中信息比较分散，让潜在客户快速找到自己是每个公司必然要面对的问题，这其中通过搜索引擎导流是一个非常重要的手段。但是整站 Ajax 对搜索引擎非常不友好，所以在一些不关注搜索引擎的场景下整站 Ajax 方案使用较为广泛，比如企业的后台系统。在尝过了前后端分离的整站Ajax 方案后，从管理到一线开发被其开发效率的提升和清晰的结构所吸引，那有没有什么方案能够享受前后端分离的优点又兼顾SEO呢？

### SSR 前传

经过一段时间的探索 SSR 方案脱颖而出，SSR 之前的方案这里简单的提几个：

开发分离发布合并，在淘宝用的比较多，将商品详情页生成为静态文件，这种方案能满足需求，但缺点是需要做一些其他工作，比如价格更新库存更新以及购买人数的更新都需要另外一套代码逻辑来处理。

为搜索引擎和真实用户准备两套呈现逻辑，通过 HTML5 History 实现资源的统一，通过 noscript 分流机器和人，缺点是页面不能有复杂的交互，因为缺少数据和页面事件的处理机制。

### SSR 同构

SSR 用通过同构的方法解决了上面问题。我们先说一下 SSR 的具体表现，比如我们现在有一个列表页，列表中每一行对应一个详情页，那么如果直接用浏览器访问列表页时，服务器返回数据和HTML融合后的页面，浏览器拿到页面直接渲染，这就省去了先请求 js 再由 js 发起数据请求的过程，页面渲染的同时请求js，js加载完成后绑定事件；从列表页中点击某一条到详情页的时候，和普通的全栈 Ajax 一样，先请求 js 再由 js 发起数据请求，然后填充数据渲染页面。如果将详情页的链接复制出来，直接在新浏览中访问，那么详情页会直接返回数据和HTML融合后的页面，渲染的同时请求详情页 js，最后再绑定事件。这个“服务器端拼接 HTML” 和 “浏览器端拼接HTML” 是由同样的页面和组件完成的，这种前后端采用同样的结构在不同的环境中产出同样的 HTML 的方案称之为“同构”。 

下面分两个层面说说怎么实现的:

第一个是路由层面，那么路由配置在前端还是后端呢？Vue 的 SSR 框架 nuxt 使用了 page 下的资源路径作为路由，比如下面这样的路径：

```js
└── pages
    ├── users
       ├── index.vue
       └── _id.vue
```

会转换成下面这样的前端路由：

```js
routes: [
    {
      name: 'users',
      path: '/',
      component: 'pages/users/index.vue'
    },
    {
      name: 'users-id',
      path: '/users/:id?',
      component: 'pages/users/_id.vue'
    }
]
```

同时会生成相应的后端路由，后端路由并没有写进文件，而是将文件夹的分析结果写入内存，然后注入 web 容器中：

```js
const app = express();
app.use(nuxt.render);
```

所以需要注意后端的数据接口和页面接口一定不能相同，比较好的办法是给数据接口加统一的前缀(比如 /api 是官方示例给的方案)。

第二个是渲染层面，

## 提速

80%

## 参考

[Nuxt官网](https://zh.nuxtjs.org/guide/async-data)

[nuxt express template](https://github.com/nuxt-community/express-template)

[美团点评点餐 Nuxt.js 实战](https://juejin.im/post/598aabe96fb9a03c335a8dde)