<!DOCTYPE html>
<html>
<head lang="zh-cn">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>js 数据类型 - 龙则的个人站点</title>
    <script>
        // 用户通过搜索引擎到文章详情页时，跳到首页并进行哈希路由
        var href = window.location.href.replace(/[^:|\/]\//,function (matchStr){
            return matchStr + 'index.html#!';
        });
        window.location.href = href.replace('/main.html', '');
    </script>
</head>
<body>
<header>
    <h1>
        龙则的个人站点
    </h1>
    <h2>
        戒躁，沉心研究业务与技术
    </h2>
</header>
<div>
    <h1 id="header-1">js 数据类型</h1>
<blockquote>
<p>js 是一种松散数据类型的语言，带来了很多便利也带来了许多麻烦，这篇谈谈分类与检测和一些需要注意的技巧。</p>
</blockquote>
<h2 id="header-1-1">分类</h2>
<p><strong>传统分类</strong></p>
<ul>
<li>值类型：string，number，boolean，undefined，null</li>
<li>引用类型：Array，Object，Regexp，Function，Date</li>
</ul>
<p><strong>typeof分类</strong></p>
<ul>
<li>可直接得到：string，number，boolean，undefined</li>
<li>object：Object，Function，Array，Date，Regexp，null</li>
</ul>
<p>注：chrome 对 Function 返回 &quot;function&quot;，其他浏览器返回 &quot;object&quot;</p>
<p><em>其他特定数据</em></p>
<p>NaN 和 Infinity（非数字和无穷大）</p>
<pre><code>&#39;a&#39; / 1                     // NaN
typeof NaN                 // number

1 / 0                        // Infinity
typeof Infinity            // number
typeof 1 / 0                 // NaN 注意运算符的优先级

Number.POSITIVE_INFINITY   // Infinity
Number.NEGATIVE_INFINITY   // -Infinity
Number.POSITIVE_INFINITY + Number.NEGATIVE_INFINITY     // NaN
</code></pre><h2 id="header-1-2">检测</h2>
<p><code>Object.prototype.toString.call</code> 系列：</p>
<pre><code>Object.prototype.toString.call(null);       // &quot;[object Null]&quot;
Object.prototype.toString.call(/\d/);       // &quot;[object RegExp]&quot;
Object.prototype.toString.call({});         // &quot;[object Object]&quot;
Object.prototype.toString.call([]);         // &quot;[object Array]&quot;
Object.prototype.toString.call(new Date()); // &quot;[object Date]&quot;
</code></pre><p><code>constructor</code> 方法只能检测当前 window 下的数据，跨 frame 无效：</p>
<pre><code>new Date().constructor === Date    // true
</code></pre><p>ES6 还提供了一些方法，跨 frame 有效：</p>
<pre><code>Array.isArray([]);    // true
</code></pre><p>还有一些特定数据的检验：NaN 和 Infinity</p>
<pre><code>NaN == NaN             // false
window.isNaN(NaN);     // true

1 / 0                  // 得到 Infinity，用 isFinite 检测却返回 false
1 / 0 === Infinity     // true，可用此法检测 Infinity
1 / 0 === Number.POSITIVE_INFINITY  // true
1 / Infinity           // 0，IE8 以上支持
</code></pre>
</div>
</body>
</html>